#!/bin/bash

################################################
#   VARIABLES - adjust these to your liking    #
################################################

min_free_space=100 # minimum free space in GB
amount_free_disks=5 # desired amount of disks with min_free_space
replot_levels="0,1,2,3,4,5,6" # comma-separated list of Plot Compressions levels that you would like to replot. Those will be (gradually) removed.
search_depth=10 # maximum search depth for plot files - how many subdir levels should we iterate?
interval=30 # rescan every xx seconds. this is AFTER removal of plot files in one iteration is finished. it is okay to set this relatively low (30s)
logfile="/var/log/plot_over.log" # set to a valid path or leave empty to disable logging

###### No variables to change below ###############

# Add color variables and bold
GREEN="\033[32m"
YELLOW="\033[33m"
CYAN="\033[36m"
RED="\033[31m"
BOLD="\033[1m"
RESET="\033[0m"

subdir="" # Default parameter for your first subdirectory for plots in Disk. This is set in the commandline now.
plot_patterns=('plot-k32-202*.plot' 'plot-k32-c1*.plot' 'plot-k32-c2*.plot' 'plot-k32-c3*..plot' 'plot-k32-c4*.plot' 'plot-k32-c5*.plot' 'plot-k32-c6*.plot' 'plot-k32-c7*.plot' 'plot-k32-c8*.plot')
min_free_space_bytes=$((min_free_space * 1000000000)) # minimum free space in bytes
IFS=',' read -ra replot_levels_arr <<< "$replot_levels"

function print_usage() {
    echo "Usage: $0 [--dry-run] [--interval interval] [--mount-dir mount_dir] [--label label]"
    echo "Note: --mount-dir and --label cannot be used at the same time."
}

function check_duf_installed() {
  if ! command -v duf >/dev/null 2>&1; then
    echo ""
    echo -e "${YELLOW}${BOLD}Duf-utility not found${RESET}"
    echo -e "${RED}For a shiny table overview of your disks here, please install ${BOLD}duf${RESET} ${RED}from${RESET} ${CYAN}${BOLD}https://github.com/muesli/duf${RESET}"
        return 1
  fi
  return 0
}

# Parse command-line arguments
dry_run=false

while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dry-run) dry_run=true; shift ;;
        --interval)
            interval="$2"
            shift 2
            ;;
        --mount-dir)
            mount_dir="$2"
            shift 2
            ;;
        --label)
            label="$2"
            shift 2
            ;;
        --subdir)
            subdir="$2"
            shift 2
            ;;    
        *)
            echo "Unknown argument: $1"
            print_usage
            exit 1
            ;;
    esac
done

## Check if the user has provided the required arguments
if [ -z "$mount_dir" ] && [ -z "$label" ]; then
    print_usage
    exit 1
fi

# Check if both --mount-dir and --label are provided
if [ -n "$mount_dir" ] && [ -n "$label" ]; then
    echo "Error: Both --mount-dir and --label cannot be used at the same time."
    print_usage
    exit 1
fi

# If --label is provided, find the mount points matching the label
if [ -n "$label" ]; then
  IFS=$'\n' read -rd '' -a disks < <(lsblk -o NAME,LABEL,MOUNTPOINT | awk -v label="$label" '$2 ~ "^"label {print $3}')
else
  # If --mount-dir is provided, use it as the base directory for directories with the pattern "CHIA-*"
  disks=("$mount_dir"*)
fi

# Append subdir to each disk if provided
if [ -n "$subdir" ]; then
  for i in "${!disks[@]}"; do
    disks[i]="${disks[i]}/$subdir"
  done
fi

while true; do
  clear

  # Count the number of disks
  disk_count="${#disks[@]}"

  if [ -n "$mount_dir" ]; then
  echo -e "Watching a total of ${CYAN}$disk_count${RESET} drives in ${CYAN}$mount_dir*${RESET}"
    elif [ -n "$label" ]; then
  echo -e "Watching a total of ${CYAN}$disk_count${RESET} drives labelled with the pattern ${CYAN}$label${RESET}"
  fi

  echo -e "${CYAN}$amount_free_disks${RESET} drives each required to have ${CYAN}$min_free_space${RESET} GB free space"
  echo -e "Plot levels marked for removal: ${CYAN}$replot_levels${RESET}"
  if [ "$dry_run" = true ]; then
    echo -e "${CYAN}DRY-RUN MODE - NOTHING WILL BE DELETED${RESET}"
  fi

   free_disks=()

  for disk in "${disks[@]}"; do
    free_space=$(df -B 1 "$disk" | awk 'NR==2 {print $4}')
    if [ "$free_space" -ge "$min_free_space_bytes" ]; then
      free_disks+=("$disk")
    fi
  done

  echo
  if [ ${#free_disks[@]} -gt 0 ]; then
    echo -e "${CYAN}${#free_disks[@]}${RESET} drives meet the requirements:"
    if check_duf_installed; then
      duf ${free_disks[@]}
    fi
  else
    echo "No drives meet the requirements."
  fi
  echo


  ## Debugging output - List of directories being processed
  if [ "$dry_run" = true ]; then
      echo -e "${YELLOW}Debugging output:${RESET}"
      echo "Processing the following directories:"
      for disk in "${disks[@]}"; do
        echo "  - $disk"
  done
  echo -e "${YELLOW}End of debugging output${RESET}"
  fi

  while [ "${#free_disks[@]}" -lt "$amount_free_disks" ]; do
    plot_found=false

    for plot_pattern_index in "${replot_levels_arr[@]}"; do
      plot_pattern="${plot_patterns[$plot_pattern_index]}"
      least_free_space_disk=""
      oldest_file=""

      for disk in "${disks[@]}"; do
        matching_files=$(find "$disk" -maxdepth "$search_depth" -name "$plot_pattern")

        if [ -n "$matching_files" ]; then
          free_space=$(df -B 1 "$disk" | awk 'NR==2 {print $4}')
          if [ "$free_space" -lt "$min_free_space_bytes" ]; then
            least_free_space_disk="$disk"
            oldest_file=$(find "$disk" -maxdepth 2 -name "$plot_pattern" -printf '%T@ %p\n' | sort | head -n 1 | cut -d ' ' -f 2)
            break
          fi
        fi
      done

if [ -n "$oldest_file" ]; then
  echo -e "${CYAN}$(date)${RESET}"
  
  if [ "$dry_run" = true ]; then
    echo "DRY-RUN would remove $oldest_file"
  else
    echo "removing $oldest_file"
    chattr -i "$oldest_file"
    rm_output=$(rm -v "$oldest_file" 2>&1)
    echo "$rm_output"
    
    if [ -n "$logfile" ]; then
      echo "$(date) - ${rm_output}" >> "$logfile"
    fi
  fi
  echo
  plot_found=true
fi

      if [ "$plot_found" == true ]; then
        sleep 4
        break
      fi
    done

    free_disks=()

    for disk in "${disks[@]}"; do
      free_space=$(df -B 1 "$disk" | awk 'NR==2 {print $4}')
      if [ "$free_space" -ge "$min_free_space_bytes" ]; then
        free_disks+=("$disk")
      fi
    done
done
  echo -e "${CYAN}$(date)${RESET}"

  if [ "${#free_disks[@]}" -ge "$amount_free_disks" ]; then
    echo -e "${CYAN}$amount_free_disks${RESET} drives with each ${CYAN}$min_free_space${RESET} GB free space found."
  elif [ "$plot_found" == false ]; then
    echo -e "No plots with Plot Compression level ${CYAN}$replot_levels${RESET} found."
  fi
  echo "No more plots need to be removed for now."
  sleep $interval
done