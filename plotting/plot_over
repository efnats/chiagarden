#!/bin/bash

################################################
#   VARIABLES - adjust these to your liking    #
################################################

min_free_space="100" # minimum free space in GB
amount_free_disks="10" # desired amount of disks with min_free_space
replot_levels="0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20" # comma-separated list of Plot Compressions levels that you would like to replot. Those will be (gradually) removed.
search_depth="10" # maximum search depth for plot files - how many subdir levels should we iterate?
interval="30" # rescan every xx seconds. this is AFTER removal of plot files in one iteration is finished. it is okay to set this relatively low (30s)
logfile="/var/log/plot_over.log" # set to a valid path or leave empty to disable logging
display_search_paths="false" # set to true to display the paths that are searched for plot files
label="CHIA" # Default parameter for your label. Can also be set in commandline.
subdir="" # Default parameter for your first subdirectory for plots in Disk. Can also be set in commandline.
###### No variables to change below ###############

# Add color variables and bold
GREEN="\033[32m"
YELLOW="\033[33m"
CYAN="\033[36m"
RED="\033[31m"
BOLD="\033[1m"
RESET="\033[0m"

plot_patterns=('plot-k32-202*.plot' 'SPECIAL_PATTERN_1' 'SPECIAL_PATTERN_2' 'SPECIAL_PATTERN_3' 'SPECIAL_PATTERN_4' 'SPECIAL_PATTERN_5' 'SPECIAL_PATTERN_6' 'SPECIAL_PATTERN_7' 'SPECIAL_PATTERN_8' 'SPECIAL_PATTERN_9' 'plot-k32-c10-*.plot' 'plot-k32-c11-*.plot' 'plot-k32-c12-*.plot' 'plot-k32-c13-*.plot' 'plot-k32-c14-*.plot' 'plot-k32-c15-*.plot' 'plot-k32-c16-*.plot' 'plot-k32-c17-*.plot' 'plot-k32-c18-*.plot' 'plot-k32-c19-*.plot' 'plot-k32-c20-*.plot')
min_free_space_bytes=$((min_free_space * 1000000000)) # minimum free space in bytes
IFS=',' read -ra replot_levels_arr <<< "$replot_levels"

# Configuration file name
config_file="plot_over.config"

# Function to load configuration from file
load_config() {
    while IFS='=' read -r key value; do
        if [[ "$key" != "" && "$key" != \#* ]]; then
            # Remove inline comments and trim whitespace
            value=$(echo "$value" | cut -d'#' -f1 | xargs)
            eval "$key='$value'"
        fi
    done < "$1"
}


# Check and Load Configuration File
CONFIG_PATHS=("/etc/chiagarden/$config_file" "$HOME/.config/chiagarden/$config_file" "./$config_file")

for path in "${CONFIG_PATHS[@]}"; do
    if [[ -f "$path" ]]; then
        echo "Loading configuration from $path"
        load_config "$path"
        break
    fi
done

# Parse command-line arguments
dry_run=false

while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dry-run) dry_run=true; shift ;;
        --interval)
            interval="$2"
            shift 2
            ;;
        --mount-dir)
            mount_dir="$2"
            shift 2
            ;;
        --label)
            label="$2"
            shift 2
            ;;
        --subdir)
            subdir="$2"
            shift 2
            ;;
        --help)
            print_help
            exit 0
            ;;
        *)
            echo "Unknown argument: $1"
            print_usage
            exit 1
            ;;
    esac
done

# Print help text
function print_help() {
    echo "Usage: $0 [--dry-run] [--interval interval] [--mount-dir mount_dir] [--label label] [--subdir subdir] [--help]"
    echo ""
    echo "Arguments:"
    echo "  --dry-run          Run the script without actually deleting any plot files."
    echo "  --interval         Set the interval in seconds between consecutive scans for plot files to remove."
    echo "  --mount-dir        Set the base directory where your plot drives are mounted (e.g., /mnt/plots/)."
    echo "  --label            Use this flag if you want the script to search for drives with a specific label pattern."
    echo "  --subdir           Set the subdirectory within the drives where plot files are located."
    echo "  --help             Display this help message and exit."
    echo ""
    echo "Note: --mount-dir and --label cannot be used at the same time."
}


# Print usage
function print_usage() {
    echo "Usage: $0 [--dry-run] [--interval interval] [--mount-dir mount_dir] [--label label]"
    echo "Note: --mount-dir and --label cannot be used at the same time."
}

# is_running_as_systemd_service() {
#     if [ -n "$INVOCATION_ID" ]; then
#         return 0 # True, running as systemd service
#     else
#         return 1 # False, not running as systemd service
#     fi
# }

is_running_as_systemd_service() {
    if [ $(ps -o comm= -p $PPID) = 'systemd' ]; then
        return 0 # True, running as systemd service
    else
        return 1 # False, not running as systemd service
    fi
}

# is_running_as_systemd_service() {
    # if [ "$RUNNING_UNDER_SYSTEMD" = "true" ]; then
        # return 0 # True, running as systemd service
    # else
        # return 1 # False, not running as systemd service
    # fi
# }


# Function to sleep for the specified interval before repeating the loop
sleep_interval() {
    echo
    echo -e "waiting ${CYAN}$interval${RESET} seconds"
    sleep "$interval"
}

# Check if duf is installed
function check_duf_installed() {
  if ! command -v duf >/dev/null 2>&1; then
    echo ""
    echo -e "${YELLOW}${BOLD}Duf-utility not found${RESET}"
    echo -e "${RED}For a shiny table overview of your disks here, please install ${BOLD}duf${RESET} ${RED}from${RESET} ${CYAN}${BOLD}https://github.com/muesli/duf${RESET}"
        return 1
  fi
  return 0
}

# Validate the command-line arguments
function validate_arguments() {
  if [ -z "$mount_dir" ] && [ -z "$label" ]; then
    print_usage
    exit 1
  fi

  if [ -n "$mount_dir" ] && [ -n "$label" ]; then
    echo "Error: Both --mount-dir and --label cannot be used at the same time."
    print_usage
    exit 1
  fi
}

# Find disks based on input parameters
function find_disks() {
  # If --label is provided, find the mount points matching the label
  if [ -n "$label" ]; then
    IFS=$'\n' read -rd '' -a disks < <(lsblk -o NAME,LABEL,MOUNTPOINT | awk -v label="$label" '$2 ~ "^"label {print $3}')
  else
    # If --mount-dir is provided, use it as the base directory for directories with the pattern "CHIA-*"
    disks=("$mount_dir"*)
  fi

  # Append subdir to each disk if provided
  if [ -n "$subdir" ]; then
    for i in "${!disks[@]}"; do
      disks[i]="${disks[i]}/$subdir"
    done
  fi
}

## Detailed info about paths to include for searching plot files
function search_path_output() {
    echo ""
    #echo -e "${YELLOW}Debugging output:${RESET}"
     echo "Processing the following directories:"
      for disk in "${disks[@]}"; do
        echo "  - $disk"
      done
    #echo -e "${YELLOW}End of debugging output${RESET}"
    echo ""
}


function get_free_disks() {
  free_disks=()
  eligible_disks=()   # Add this array to keep track of disks eligible for plot removal

  for disk in "${disks[@]}"; do
    free_space=$(df -B 1 "$disk" | awk 'NR==2 {print $4}')
    if [ "$free_space" -ge "$min_free_space_bytes" ]; then
      free_disks+=("$disk")
    else
      eligible_disks+=("$disk")   # Populate this list with disks that don't meet the minimum free space requirement
    fi
  done

  if [ "${#free_disks[@]}" -ge "$amount_free_disks" ]; then
    enough_free_disks=true
  else
    enough_free_disks=false
  fi
}


function find_oldest_plot() {
  local level=$1
  oldest_file=""
  oldest_timestamp=$(date +%s)
  file_count=0

  # Change the loop to iterate over eligible_disks instead of all disks
  for disk in "${eligible_disks[@]}"; do
    if [[ "$level" -ge 1 && "$level" -le 9 ]]; then
      single_digit=$(($level))
      double_digit=$(printf "%02d" $level)
      find_output=$(find "$disk" -maxdepth "$search_depth" -type f \( -name "plot-k32-c${single_digit}-*.plot" -o -name "plot-k32-c${double_digit}-*.plot" \) -printf '%T@ %p\n' 2>/dev/null)
    else
      find_output=$(find "$disk" -maxdepth "$search_depth" -type f -name "${plot_patterns[$level]}" -printf '%T@ %p\n' 2>/dev/null)
    fi

    if [ -n "$find_output" ]; then
      while IFS= read -r line; do
        timestamp=$(echo "$line" | awk '{print $1}')
        file=$(echo "$line" | awk '{print $2}')

        if [ "$(echo "$timestamp < $oldest_timestamp" | bc)" -eq 1 ]; then
          oldest_timestamp=$timestamp
          oldest_file=$file
        fi
        file_count=$((file_count + 1))
      done <<< "$find_output"
    fi
  done
}



# Remove identified plot and log action into logfile
function remove_oldest_plot() {
    if [ -n "$oldest_file" ]; then
        # Determine if running as systemd service
        if is_running_as_systemd_service; then
            date_prefix=""
        else
            date_prefix="${CYAN}$(date)${RESET} "
        fi

        # Output message
        if [ "$dry_run" = true ]; then
            echo -e "${date_prefix}DRY-RUN would remove $oldest_file"
        else
            echo -e "${date_prefix}removing $oldest_file"
            rm_output=$(rm -v "$oldest_file" 2>&1)
            echo -e "${date_prefix}$rm_output"
        fi

        # Log to file only if not running as systemd service
        if ! is_running_as_systemd_service && [ -n "$logfile" ]; then
            echo "$(date) - ${rm_output}" >> "$logfile"
        fi

        echo
        plot_removed=true
    fi
}



# Find and remove the oldest plot file based on the provided compression level or skip in certain conditions
function process_plot_files() {
  # Determine if running as systemd service
  if is_running_as_systemd_service; then
      date_prefix=""
  else
      date_prefix="${CYAN}$(date)${RESET} "
  fi
  get_free_disks

  if [ "$enough_free_disks" = false ]; then
    no_matching_plots_found=false

    while [ "$enough_free_disks" = false ] && [ "$no_matching_plots_found" = false ]; do
      plot_removed=false

      echo -e "${date_prefix}Finding next plot for removal.."

      for level in "${replot_levels_arr[@]}"; do
        if [ "$plot_removed" = false ]; then
          find_oldest_plot "$level"
          remove_oldest_plot
          if [ "$plot_removed" = true ]; then
            sleep 2
            break
          fi
        fi
      done

      # Update the number of free disks after removing the plot
      get_free_disks

      # If no files with matching plot patterns were found
      if [ $file_count -eq 0 ]; then
        echo -e "${date_prefix}No plot files with matching patterns were found."
        no_matching_plots_found=true
      fi
    done
  else
    echo -e "${date_prefix}There are enough free disks. No need to remove any plot files."
  fi
}

# Display information about the script's settings and monitored disks
function display_info() {
  disk_count="${#disks[@]}"

  if [ -n "$mount_dir" ]; then
  echo -e "Watching a total of ${CYAN}$disk_count${RESET} drives in ${CYAN}$mount_dir*${RESET}"
    elif [ -n "$label" ]; then
  echo -e "Watching a total of ${CYAN}$disk_count${RESET} drives labelled with the pattern ${CYAN}$label${RESET}"
  fi

  echo -e "${CYAN}$amount_free_disks${RESET} drives each required to have ${CYAN}$min_free_space${RESET} GB free space"
  echo -e "Plot levels marked for removal: ${CYAN}$replot_levels${RESET}"
  echo -e
  if [ "$dry_run" = true ]; then
    echo ""
    echo -e "${CYAN}DRY-RUN MODE - NOTHING WILL BE DELETED${RESET}"
    echo ""
  fi
  if [ "$display_search_paths" = true ]; then
  search_path_output
  fi
}

# Display information about free disks
function display_free_disks_info() {
  get_free_disks
  if [ ${#free_disks[@]} -gt 0 ]; then
    echo -e "${CYAN}${#free_disks[@]}${RESET} drives meet the requirements"
    
    # Execute duf command only if not running as systemd service and duf is installed
    if ! is_running_as_systemd_service && check_duf_installed; then
      duf ${free_disks[@]}
      echo ""
    fi
  else
    echo "No drives meet the requirements. Marking plots for removal.."
  fi
}


validate_arguments
find_disks
while true; do
  if ! is_running_as_systemd_service; then
    clear
    echo -e ${BOLD}Chiagarden plot_over${RESET}
    echo
  fi
  display_info
  display_free_disks_info
  process_plot_files
  sleep_interval
done
