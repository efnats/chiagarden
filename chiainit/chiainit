#!/bin/bash

#requirements
#xfsprogs, smartmontools, ntfs-3g

XFSOPTIONS="-f -b size=1024"
EXT4OPTIONS="-F -m 0 -T largefile4"
NTFSOPTIONS="-f"
SERIALPREFIX="CHIA"

# Add color variables and bold
GREEN="\033[32m"
YELLOW="\033[33m"
CYAN="\033[36m"
RED="\033[31m"
BOLD="\033[1m"
RESET="\033[0m"

VERSION="V2.3"
ACTION=""
FSTYPE=""
DRY_RUN=false
LOGFILE=""
SHOW_SMART=false

# Function to set up logging if requested
setup_logging() {
    if [[ -n "$LOGFILE" ]]; then
        echo "Logging to $LOGFILE"
        exec > >(tee -a "$LOGFILE") 2>&1
        echo "=== ChiaInit Log $(date) ==="
    fi
}


# Function to retrieve the serial number of a drive
get_serial_number() {
    drive=$1
    serial_number=$(sudo smartctl -i /dev/$drive | grep -i "Serial Number" | awk  '{ print $3 }')
    if [ -z "$serial_number" ]; then
        echo "UNKNOWN"
    else
        echo "$serial_number"
    fi
}


# Function to retrieve the UUID of a partition
get_uuid() {
    partition=$1
    uuid=$(sudo blkid -o value -s UUID /dev/$partition)
    if [ -z "$uuid" ]; then
        echo "could not get UUID"
    else
        echo "$uuid"
    fi
}


# Function to get the filesystem type of a drive
get_fs_type() {
    partition=$1
    fs_type=$(sudo blkid -o value -s TYPE /dev/$partition)
    echo "$fs_type"
}

# Function to get the size of a drive
get_drive_size() {
    drive=$1
    size=$(lsblk -dn -o SIZE /dev/$drive | tr -d '[:space:]')
    echo "$size"
}


# Function to get SMART data for a drive
get_smart_data() {
    local drive=$1
    local smart_output=$(sudo smartctl -A /dev/$drive 2>/dev/null)
    local health=$(sudo smartctl -H /dev/$drive 2>/dev/null | grep -i "SMART overall-health" | awk -F': ' '{print $2}')
    
    # Temperature (ID 194 or 190)
    local temp=$(echo "$smart_output" | grep -E "^ *194|^ *190" | head -1 | awk '{print $10}')
    [[ -z "$temp" ]] && temp="-"
    
    # Power-On Hours (ID 9)
    local hours=$(echo "$smart_output" | grep -E "^ *9 " | awk '{print $10}')
    [[ -z "$hours" ]] && hours="-"
    
    # Reallocated Sectors (ID 5)
    local realloc=$(echo "$smart_output" | grep -E "^ *5 " | awk '{print $10}')
    [[ -z "$realloc" ]] && realloc="-"
    
    # Determine status
    local status="OK"
    if [[ "$health" != "PASSED" ]]; then
        status="FAIL"
    elif [[ "$realloc" != "-" && "$realloc" -gt 0 ]]; then
        status="WARN"
    fi
    
    echo "$temp $hours $realloc $status"
}


# Confirm destructive actions
confirm_destructive_action() {
    drives=$@
    echo -e "${RED}WARNING:${RESET} You have selected a destructive action (wipe, format, or init)."
    echo -e "${BOLD}THIS WILL DESTROY ALL YOUR DATA ON THE SPECIFIED DRIVE(S).${RESET}"
    for drive in "${drives[@]}"; do
        echo -e "${BOLD}${CYAN}$drive${RESET}"
    done
    echo ""
    echo "To proceed, type 'YES I SACRIFICE THIS DATA' and press Enter."
    read confirmation
    if [ "$confirmation" != "YES I SACRIFICE THIS DATA" ]; then
        echo "Operation canceled."
        exit 0
    fi
}


summarize_actions() {
    ntfs_warning=false
    local drive_count=${#DRIVES[@]}
    local excluded_count=${#EXCLUDED_LIST[@]}
    echo
    echo -e ${BOLD}"Operation Summary"${RESET}
    if $DRY_RUN; then
        echo -e "${YELLOW}>>> DRY RUN - no changes will be made <<<${RESET}"
    fi
    printf "%-13s: ${BOLD}%s${RESET}\n" "Drives ($drive_count)" "${DRIVES[*]}"
    if [[ $excluded_count -gt 0 ]]; then
        printf "%-13s: ${BOLD}%s${RESET}\n" "Excluded ($excluded_count)" "${EXCLUDED_LIST[*]}"
    fi
    printf "%-13s: ${BOLD}%s${RESET}\n" "Filesystem" "$FSTYPE"
    printf "%-13s: ${BOLD}%s${RESET}\n" "Actions" "${ACTION#--}"
    if [[ "$ACTION" == "--label" || "$ACTION" == "--init" ]]; then
        printf "%-13s: ${BOLD}%s${RESET}\n" "Label prefix" "$SERIALPREFIX"
    fi
    
    if [[ "$ACTION" == "--label" ]]; then
        echo -e "\n${GREEN}Note:${RESET} Labeling is non-destructive. Your data will be preserved."
    fi
    echo

    # Check if any of the drives have the ntfs filesystem and display a warning
    for drive in "${DRIVES[@]}"; do
        if [ "$FSTYPE" == "ntfs" ]; then
            ntfs_warning=true
            break
        fi
    done

    if [ "$ntfs_warning" = true ]; then
        echo -e "${RED}WARNING!!${RESET}${BOLD} There is a potential risk for data corruption when using NTFS-3G for Windows. DONT USE IT FOR YOUR FARM!!${RESET}"
        echo
    fi

    echo "Do you want to continue? (Y/n)"
    read -r user_choice
    if [[ ! "$user_choice" =~ ^[Yy]$ ]] && [[ ! -z "$user_choice" ]]; then
        echo "Operation canceled."
        exit 0
    fi
}


# Function to label a drive
label() {
    drive=$1
    partition="${drive}1"

    # Perform labeling
    echo -e "\n${BOLD}Labeling /dev/$partition${RESET}"
    serial_number=$(get_serial_number "$drive")
    uuid=$(get_uuid "$partition")
    
    if [ "$serial_number" == "UNKNOWN" ]; then
        serial_number=$uuid
    fi
    label="${SERIALPREFIX}-${serial_number}"
    FSTYPE=$(get_fs_type "$partition")

    case "$FSTYPE" in
        xfs)
            label=$(echo "$label" | cut -c 1-12)
            sudo xfs_admin -L "$label" /dev/$partition
            ;;
        ext4)
            label=$(echo "$label" | cut -c 1-16)
            sudo e2label /dev/$partition "$label"
            ;;
        ntfs)
            label=$(echo "$label" | cut -c 1-32)
            sudo ntfslabel /dev/$partition "$label"
            ;;
    esac

    local exit_status=$?
    return $exit_status
}


# Function to get the label of a drive
get_label() {
    partition=$1
    readlabel=""
    fs_type=$(get_fs_type "$partition")

    case "$fs_type" in
        xfs)
            readlabel=$(sudo xfs_admin -l /dev/$partition 2>/dev/null | awk '{print $3}')
            ;;
        ntfs)
            readlabel=$(sudo ntfslabel /dev/$partition 2>/dev/null)
            ;;
        ext4)
            readlabel=$(sudo e2label /dev/$partition 2>/dev/null)
            ;;
    esac
    echo "$readlabel"
}


# Function to wipe a drive
wipe() {
    drive=$1
    sudo wipefs -a /dev/$drive
    local exit_status=$?
    return $exit_status
}


# Function to format a drive
format() {
    drive=$1
    if [ -z "$FSTYPE" ]; then
        return
    fi

    partition="${drive}1"

    # Partition, sync, and format the drive
        sudo parted /dev/$drive --script mklabel gpt mkpart primary $FSTYPE 0% 100%
        sudo sync
        if [ "$FSTYPE" == "xfs" ]; then
            sudo mkfs.xfs ${XFSOPTIONS} /dev/$partition
        elif [ "$FSTYPE" == "ext4" ]; then
            sudo mkfs.ext4 ${EXT4OPTIONS} /dev/$partition
        elif [ "$FSTYPE" == "ntfs" ]; then
            sudo mkfs.ntfs ${NTFSOPTIONS} /dev/$partition
        fi

    local exit_status=$?
    return $exit_status
}


# Function to initialize a drive (wipe, format, and label)
init() {
    drive=$1
    
    execute_action "--wipe" "$drive" "" ""
    execute_action "--format" "$drive" "" ""
    execute_action "--label" "$drive" "" ""
    
    # Check if initialization succeeded by verifying label exists
    local label=$(get_label "${drive}1")
    [[ -n "$label" ]]
}


# List all spinning drives in the system using lsblk and exclude ROM drives
get_drives() {
    lsblk -d -o name,rota,type | awk '$2 == "1" && $3 != "rom" {print $1}'
}


increment_drive() {
    local drive=$1

    # Base case: If drive is empty, return "a"
    if [ -z "$drive" ]; then
        echo "a"
        return
    fi

    # Get the last character of the drive and the rest of the drive
    local lastchar="${drive: -1}"
    local remainder="${drive%?}"

    # If the last character is not 'z', increment it
    if [ "$lastchar" != "z" ]; then
        local nextchar=$(printf "\\$(printf '%03o' "$(( $(printf '%d' "'$lastchar'") + 1 ))" )")
        echo "${remainder}${nextchar}"
    else
        # If the last character is 'z', set it to 'a' and increment the next character recursively
        echo "$(increment_drive "$remainder")a"
    fi
}


expand_drive_range() {
    local range="$1"
    local prefix="sd"
    
    # Split the range into start and end using dash as delimiter
    local start="${range%-*}"
    local end="${range#*-}"

    # Remove prefix
    start="${start#$prefix}"
    end="${end#$prefix}"

    local current_drive="$start"

    while [ "$current_drive" != "$end" ]; do
        echo "${prefix}${current_drive}"
        current_drive=$(increment_drive "$current_drive")
    done
    echo "${prefix}${current_drive}"
}



# List all drives with details
list_drives() {
    local show_smart=$1
    shift
    local drives=("$@")
    local labeled=0
    local unlabeled=0
    
    # If no drives specified, get all
    if [[ ${#drives[@]} -eq 0 ]]; then
        drives=($(get_drives))
    fi
    
    echo
    if [[ "$show_smart" == "true" ]]; then
        echo -e "${BOLD}Drive        Size     Label            FS      Temp   Hours    Realloc  Status${RESET}"
        echo "-----        ----     -----            --      ----   -----    -------  ------"
    else
        echo -e "${BOLD}Drive        Size     Label            Filesystem   Serial${RESET}"
        echo "-----        ----     -----            ----------   ------"
    fi
    
    for drive in "${drives[@]}"; do
        local size=$(get_drive_size "$drive")
        local partition="${drive}1"
        local label=$(get_label "$partition" 2>/dev/null)
        local fstype=$(get_fs_type "$partition" 2>/dev/null)
        local serial=$(get_serial_number "$drive")
        
        # Track labeled/unlabeled and format output
        local label_out fstype_out serial_out
        if [[ -z "$label" ]]; then
            label_out=$(printf "${YELLOW}%-16s${RESET}" "(none)")
            ((unlabeled++))
        else
            label_out=$(printf "%-16s" "$label")
            ((labeled++))
        fi
        
        if [[ -z "$fstype" ]]; then
            fstype_out=$(printf "${YELLOW}%-7s${RESET}" "(none)")
        else
            fstype_out=$(printf "%-7s" "$fstype")
        fi
        
        printf "%-12s %-8s " "/dev/$drive" "$size"
        
        if [[ "$show_smart" == "true" ]]; then
            local smart_data=$(get_smart_data "$drive")
            local temp=$(echo "$smart_data" | awk '{print $1}')
            local hours=$(echo "$smart_data" | awk '{print $2}')
            local realloc=$(echo "$smart_data" | awk '{print $3}')
            local status=$(echo "$smart_data" | awk '{print $4}')
            
            # Format temperature
            local temp_out
            if [[ "$temp" == "-" ]]; then
                temp_out="${YELLOW}-${RESET}    "
            else
                temp_out="${temp}°C  "
            fi
            
            # Format hours
            local hours_out
            if [[ "$hours" == "-" ]]; then
                hours_out="${YELLOW}-${RESET}       "
            else
                hours_out=$(printf "%-8s" "$hours")
            fi
            
            # Format reallocated sectors with color
            local realloc_out
            if [[ "$realloc" == "-" ]]; then
                realloc_out="${YELLOW}-${RESET}       "
            elif [[ "$realloc" -gt 0 ]]; then
                realloc_out=$(printf "${YELLOW}%-8s${RESET}" "$realloc")
            else
                realloc_out=$(printf "%-8s" "$realloc")
            fi
            
            # Format status with color
            local status_out
            case "$status" in
                OK)   status_out="${GREEN}OK${RESET}" ;;
                WARN) status_out="${YELLOW}WARN${RESET}" ;;
                FAIL) status_out="${RED}FAIL${RESET}" ;;
            esac
            
            echo -e "${label_out} ${fstype_out} ${temp_out} ${hours_out} ${realloc_out} ${status_out}"
        else
            if [[ "$serial" == "UNKNOWN" ]]; then
                serial_out="${YELLOW}(unknown)${RESET}"
            else
                serial_out="$serial"
            fi
            # Adjust fstype width for non-smart output
            if [[ -z "$fstype" ]]; then
                fstype_out=$(printf "${YELLOW}%-12s${RESET}" "(none)")
            else
                fstype_out=$(printf "%-12s" "$fstype")
            fi
            echo -e "${label_out} ${fstype_out} ${serial_out}"
        fi
    done
    
    local total=${#drives[@]}
    echo
    echo -e "Found ${BOLD}${total}${RESET} drives (${GREEN}${labeled} labeled${RESET}, ${YELLOW}${unlabeled} unlabeled${RESET})"
    echo
}


# Function to check if a drive has a mounted root partition
is_system_drive() {
    drive=$1
    root_partition=$(df --output=source / | tail -1)
    echo $root_partition | grep -q "^/dev/${drive}[0-9]*"
    return $?
}


# Function to check if each specified drive exists
check_drives_exist() {
    for drive in "${DRIVES[@]}"; do
        if ! [ -b "/dev/${drive}" ]; then
            echo -e "${RED}Error:${RESET} Drive /dev/$drive does not exist."
            exit 1
        fi
    done
}


# Function to check if any of the specified drives are mounted
is_drive_mounted() {
    drive=$1
    grep -qs "/dev/${drive}[0-9]* " /proc/mounts
    return $?
}


# Check if fstype is issued for format or label action
check_fstype_issued() {
if { [ "$ACTION" == "--format" ] || [ "$ACTION" == "--init" ]; } && [ -z "$FSTYPE" ]; then
    echo "Error: Missing filesystem type for format or label action."
    display_usage
    exit 1
fi
}


# Function to display the help text
help() {
    display_version
    display_help
}


# Display help text
display_help() {
    echo "Usage: chiainit [OPTIONS] drive1 drive2 ... driveN"
    echo "Mass-prepare hard drives for PoST farming"
    echo ""
    echo "Actions:"
    echo "  --list                      List drives with labels and details"
    echo "  --wipe                      Wipe the specified drives"
    echo "  --format                    Format the specified drives (requires --fstype)"
    echo "  --label                     Label the specified drives (non-destructive)"
    echo "  --init                      Wipe, format, and label (requires --fstype)"
    echo ""
    echo "Options:"
    echo "  --smart                     Show SMART data (use with --list)"
    echo "  --fstype [xfs|ext4|ntfs]    Specify the filesystem type"
    echo "  --label-prefix PREFIX       Custom label prefix (default: CHIA)"
    echo "  --all                       Operate on all drives (excluding system drives)"
    echo "  --exclude drive1 drive2     Exclude drives from the operation"
    echo "  --dry-run                   Show what would be done without making changes"
    echo "  --log [FILE]                Write log (default: ./chiainit-DATE.log)"
    echo "  --help                      Show this help"
    echo ""
    echo "Examples:"
    echo "  chiainit --list --all"
    echo "  chiainit --list sda-sdd"
    echo "  chiainit --list --smart sda sdb sdc"
    echo "  chiainit --label sda sdb"
    echo "  chiainit --label-prefix FARM --label sda sdb"
    echo "  chiainit --fstype xfs --init sda-sdz"
    echo "  chiainit --fstype xfs --init --all --exclude sda sdb"
    echo "  chiainit --dry-run --fstype xfs --init sda-sdd"
}


# Display short help text
display_usage() {
    echo "Usage: chiainit [OPTIONS] [drive-range1] [drive-range2] ... driveN"
    echo "Example: chiainit --fstype ext4 --init sda-sdz"
}


display_version() {
    echo -e "${BOLD}${CYAN}ChiaInit ${VERSION}${RESET}"
}



# Spinner code
spinner=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
export spin=true

start_spinner() {
    local message=$1
    spin=true
    tput civis # Hide cursor

    while $spin; do
        for i in "${spinner[@]}"; do
            printf "\r$i $message"
            sleep 0.1
        done
    done &
    spinner_pid=$!
}

stop_spinner() {
    # Kill the spinner process
    if [ ! -z "$spinner_pid" ]; then
        kill "$spinner_pid" 2>/dev/null
    fi
    tput cnorm # Show cursor
    printf "\r%s\r" "$(printf ' %.0s' {1..50})" # Clear line
}



# Execute action
execute_action() {
    action=$1
    drive=$2
    local current=$3
    local total=$4
    local progress=""
    [[ -n "$current" && -n "$total" ]] && progress="[${current}/${total}] "
    local output
    local exit_status
    local drive_size=$(get_drive_size $drive)

    case "$action" in
        --init)
            echo -e "\n${BOLD}${CYAN}${progress}Drive /dev/$drive [$drive_size]${RESET}"
            if $DRY_RUN; then
                echo -e "  ${YELLOW}[DRY-RUN]${RESET} Would wipe /dev/$drive"
                echo -e "  ${YELLOW}[DRY-RUN]${RESET} Would format /dev/$drive as $FSTYPE"
                serial_number=$(get_serial_number "$drive")
                [[ "$serial_number" == "UNKNOWN" ]] && serial_number=$(get_uuid "${drive}1" 2>/dev/null || echo "unknown")
                echo -e "  ${YELLOW}[DRY-RUN]${RESET} Would label as ${SERIALPREFIX}-${serial_number}"
            else
                if init $drive; then
                    ((success_count++))
                else
                    ((failed_count++))
                fi
            fi
            ;;
        --wipe)
            if $DRY_RUN; then
                echo -e "${YELLOW}${progress}[DRY-RUN]${RESET} Would wipe /dev/$drive [$drive_size]"
            else
                start_spinner "${progress}/dev/$drive wiping"
                output=$(wipe $drive 2>&1)
                exit_status=$?
                stop_spinner
                if [ $exit_status -eq 0 ]; then
                    echo -e "${progress}\e[32m✔\e[0m ${CYAN}/dev/$drive${RESET} wiping...... ${GREEN}ok${RESET}"
                    [[ -n "$current" ]] && ((success_count++))
                else
                    echo -e "${progress}\e[31m✖\e[0m ${CYAN}/dev/$drive${RESET} wiping...... ${RED}failed${RESET}"
                    echo "$output"
                    [[ -n "$current" ]] && ((failed_count++))
                fi
                [[ -n "$LOGFILE" ]] && echo -e "\n$output" >> "$LOGFILE"
            fi
            ;;
        --format)
            if $DRY_RUN; then
                echo -e "${YELLOW}${progress}[DRY-RUN]${RESET} Would format /dev/$drive [$drive_size] as $FSTYPE"
            else
                start_spinner "${progress}/dev/$drive formatting"
                output=$(format $drive 2>&1)
                exit_status=$?
                stop_spinner
                if [ $exit_status -eq 0 ]; then
                    actual_fstype=$(get_fs_type "${drive}1")
                    echo -e "${progress}\e[32m✔\e[0m ${CYAN}/dev/$drive${RESET} formatting.. ${GREEN}$actual_fstype${RESET}"
                    [[ -n "$current" ]] && ((success_count++))
                else
                    echo -e "${progress}\e[31m✖\e[0m ${CYAN}/dev/$drive${RESET} formatting.. ${RED}failed${RESET}"
                    echo "$output"
                    [[ -n "$current" ]] && ((failed_count++))
                fi
                [[ -n "$LOGFILE" ]] && echo "$output" >> "$LOGFILE"
            fi
            ;;
        --label)
            if $DRY_RUN; then
                serial_number=$(get_serial_number "$drive")
                [[ "$serial_number" == "UNKNOWN" ]] && serial_number=$(get_uuid "${drive}1" 2>/dev/null || echo "unknown")
                echo -e "${YELLOW}${progress}[DRY-RUN]${RESET} Would label /dev/$drive [$drive_size] as ${SERIALPREFIX}-${serial_number}"
            else
                start_spinner "${progress}/dev/$drive labelling"
                partition="${drive}1"
                output=$(label $drive "$partition" 2>&1)
                exit_status=$?
                stop_spinner
                [[ -n "$LOGFILE" ]] && echo "$output" >> "$LOGFILE"
                if [ $exit_status -eq 0 ]; then
                    actual_label=$(get_label "$partition")
                    echo -e "${progress}\e[32m✔\e[0m ${CYAN}/dev/$drive${RESET} labeling.... ${GREEN}${actual_label}${RESET}"
                    [[ -n "$current" ]] && ((success_count++))
                else
                    echo -e "${progress}\e[31m✖\e[0m ${CYAN}/dev/$drive${RESET} labeling.... ${RED}failed${RESET}"
                    echo "$output"
                    [[ -n "$current" ]] && ((failed_count++))
                fi
            fi
            ;;
            
    esac
}


declare -a drives=()

# Process the command-line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --wipe|--format|--label|--init)
            ACTION="$1"
            shift
            ;;
        --list)
            ACTION="--list"
            shift
            ;;
        --smart)
            SHOW_SMART=true
            shift
            ;;
        --fstype)
            [[ "$2" =~ ^(xfs|ext4|ntfs)$ ]] && FSTYPE="$2" || { echo "Error: Unsupported filesystem type."; display_usage; exit 1; }
            shift 2
            ;;
        --label-prefix)
            SERIALPREFIX="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --log)
            if [[ -n "${2:-}" && "${2:0:1}" != "-" ]]; then
                LOGFILE="$2"
                shift 2
            else
                LOGFILE="./chiainit-$(date +%Y%m%d-%H%M%S).log"
                shift
            fi
            ;;
        --all)
            mapfile -t DRIVES < <(get_drives)
            shift
            ;;
        --exclude)
            while [[ "$#" -gt 1 && ! "$2" =~ ^-- ]]; do
                # echo "Processing exclusion: $2"  # Debug print
                # Check if it's a range
                if [[ $2 == *-* ]]; then
                    for drive in $(expand_drive_range "${2%-*}" "${2##*-}"); do
                        EXCLUDED_DRIVES+=("$drive")
                    done
                else
                    EXCLUDED_DRIVES+=("$2")
                fi
                shift  # Shift once for the processed argument
            done
            shift  # Shift once for the --exclude option itself
            ;;
        --help)
            help
            exit 0
            ;;
        *)
            [ -z "$ACTION" ] && { display_usage; exit 1; }
            # Assume it's either a range or a drive
            # echo "Processing argument: $1"  # Just for debugging purposes
            if [[ $1 == *-* ]]; then
                # It's a range
                for drive in $(expand_drive_range "$1"); do
                    DRIVES+=("$drive")
                done
            else
                # It's a single drive
                DRIVES+=("$1")
            fi
            shift
            ;;
        esac
done


# Handle --list action
if [[ "$ACTION" == "--list" ]]; then
    display_version
    # For --list, use DRIVES if specified, otherwise get all drives
    if [[ ${#DRIVES[@]} -eq 0 ]]; then
        mapfile -t DRIVES < <(get_drives)
    fi
    # Apply exclusions
    LIST_DRIVES_FILTERED=()
    for drive in "${DRIVES[@]}"; do
        if [[ " ${EXCLUDED_DRIVES[*]} " != *"$drive"* ]]; then
            LIST_DRIVES_FILTERED+=("$drive")
        fi
    done
    list_drives "$SHOW_SMART" "${LIST_DRIVES_FILTERED[@]}"
    exit 0
fi


# Initialize arrays
EXCLUDED_LIST=()
NON_EXCLUDED_DRIVES=()
echo

# Filter out the system drive and user-excluded drives
for drive in "${DRIVES[@]}"; do
    if is_system_drive "$drive"; then
        echo -e "${YELLOW}INFO:${RESET} Drive ${BOLD}${drive}${RESET} is a system drive. Excluding."
        EXCLUDED_LIST+=("$drive")
    elif [[ " ${EXCLUDED_DRIVES[*]} " == *"$drive"* ]]; then
        echo -e "${YELLOW}INFO:${RESET} Drive ${BOLD}${drive}${RESET} is manually excluded."
        EXCLUDED_LIST+=("$drive")
    else
        NON_EXCLUDED_DRIVES+=("$drive")
    fi
done

# Update DRIVES to only include non-excluded drives
DRIVES=("${NON_EXCLUDED_DRIVES[@]}")


check_fstype_issued
check_drives_exist
setup_logging
summarize_actions


# Check for and confirm destructive actions (skip in dry-run mode)
if [[ "$ACTION" == "--wipe" || "$ACTION" == "--format" || "$ACTION" == "--init" ]] && ! $DRY_RUN; then
    confirm_destructive_action "${DRIVES[@]}"
fi

total=${#DRIVES[@]}
current=0
success_count=0
failed_count=0


for drive in "${DRIVES[@]}"; do
    # Skip if the drive is in the excluded list
    if [[ " ${EXCLUDED_LIST[*]} " == *" $drive "* ]]; then
        echo "Skipping operations on excluded drive: $drive"
        continue
    fi
    ((current++))
    execute_action "$ACTION" "$drive" "$current" "$total"
done

if $DRY_RUN; then
    echo -e "\n${YELLOW}Dry run complete. No changes were made.${RESET}\n"
else
    echo
    echo -e "${BOLD}Summary${RESET}"
    echo -e "${GREEN}Success: ${success_count}${RESET}  ${RED}Failed: ${failed_count}${RESET}"
    echo
fi

